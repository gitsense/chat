/*
 * GitSense Chat - Minified Distribution File
 *
 * This JavaScript file is part of the minified distribution of GitSense Chat.
 * It has been optimized (minified) for performance and efficient delivery.
 *
 * This software is permitted for internal use and modification.
 * Copying for profit or redistribution is strictly not permitted.
 *
 * The Fair License, which formalizes these terms, will be adopted as the official license in the future.
 * Once finalized, the unminified source code will be freely available for internal use for non-
 * commercial purposes.
 *
 * This software may not be used to develop or enhance any product or service that competes
 * directly or indirectly with GitSense Chat without explicit permission.
 *
 * Copyright (c) 2025 GitSense. All rights reserved.
 */

let fs=require("fs").promises,path=require("path"),CodeBlockUtils=require("@gitsense/gsc-utils").CodeBlockUtils;async function readConfig(t){var e=path.join(t,"config.json");try{var r=await fs.readFile(e,"utf8");return JSON.parse(r)}catch(e){return"ENOENT"!==e.code&&console.warn(`Warning: Failed to parse config.json in ${t}: `+e.message),null}}async function isDirectoryEmpty(e){try{var t=await fs.readdir(e);return 0===t.length||1===t.length&&"config.json"===t[0]}catch(e){if("ENOENT"===e.code)return!0;throw e}}function isValidDirName(e){return!e.startsWith("_")&&!e.includes(".")&&/^[a-zA-Z0-9_-]+$/.test(e)}async function getAnalyzers(t){var e,r=[];try{for(e of await fs.readdir(t,{withFileTypes:!0}))if(e.isDirectory()&&isValidDirName(e.name)){var a,n=e.name,s=path.join(t,n),i=await readConfig(s),o=i?.label||n;for(a of await fs.readdir(s,{withFileTypes:!0}))if(a.isDirectory()&&isValidDirName(a.name)){var c,l=a.name,d=path.join(s,l),u=(await readConfig(d))?.label||l;for(c of await fs.readdir(d,{withFileTypes:!0}))if(c.isDirectory()&&isValidDirName(c.name)){var y=c.name,f=path.join(d,y),p=(await readConfig(f))?.label||y,g=path.join(f,"1.md");try{if(await fs.access(g),n.startsWith("tutorial-"))if((await fs.stat(g)).mtime.getTime()<Date.now()-36e5)continue;let e=n+`::${l}::`+y;var m=o+` (${u} - ${p})`;r.push({id:e,label:m,protected:i?.protected||!1})}catch(e){"ENOENT"!==e.code&&console.warn(`Warning: Error accessing 1.md for ${analyzerId}: `+e.message)}}}}}catch(e){throw console.error(`Error traversing analyze messages directory ${t}: `+e.message),e}return r}function deduceSchemaType(e,t){var r,a={type:"string"};return"string"!=typeof e?"object"==(r=typeof e)&&null!==e?(console.warn(`Warning: Unexpected non-string, non-null object/array value for field "${t}". Defaulting to type 'string'. Value:`,e),a):{type:r}:(r=e.trim(),/^\[string:.*\]$/.test(r)||/^\[[^:]+\]$/.test(r)&&!/^\[(number|datetime|date|<string>):.*\]$/.test(r)?{type:"string"}:/^\[number:.*\]$/.test(r)?{type:"number"}:/^\[boolean:.*\]$/.test(r)?{type:"boolean"}:/^\[date-*time:.*\]$/.test(r)?{type:"string",format:"date-time"}:/^\[date:.*\]$/.test(r)?{type:"string",format:"date"}:/^\[<string>:.*\]$/.test(r)||r.toLowerCase().includes("array of strings")?{type:"array",items:{type:"string"}}:r.toLowerCase().includes("output 'true' or 'false'")||r.toLowerCase().includes("determine if")&&(r.toLowerCase().includes("true")||r.toLowerCase().includes("false"))?{type:"boolean"}:(console.warn(`Warning: Unknown metadata value pattern for field "${t}". Defaulting to type 'string'. Value: "${e}"`),a))}async function getAnalyzerSchema(t,r){if("string"!=typeof t||""===t.trim())return console.error("Error: analyzeMessagesBasePath is required."),null;if("string"!=typeof r||""===r.trim())return console.error("Error: analyzerId is required."),null;var e=r.split("::");if(3!==e.length)return console.error(`Error: Invalid analyzerId format. Expected 'analyzer_name::content_type::instructions_type', but got '${r}'.`),null;var[e,a,n]=e,t=path.join(t,e,a,n,"1.md");try{var s=await fs.readFile(t,"utf8"),i=CodeBlockUtils.extractCodeBlocks(s,{silent:!0}).blocks,o=i.filter(e=>"code"===e.type&&"json"===e.language);if(1!==o.length)throw new Error(`Expected exactly one JSON code block in ${t}, but found ${o.length}.`);var c=o[0].content;let e=null;try{e=JSON.parse(c)}catch(e){return console.error(`Error parsing JSON content from ${t}: `+e.message),null}var l,d,u,y={type:"object",description:e.description,properties:{},required:[]},f=e?.extracted_metadata;if(f&&"object"==typeof f)for(var p in f)Object.hasOwnProperty.call(f,p)&&(d=deduceSchemaType(l=f[p],p),u=l.match(/^\[\w+: ([^\]]+)\]/)?.[1]||"",y.properties[p]={...d,description:u,title:p.replace(/_/g," ").replace(/\b\w/g,e=>e.toUpperCase())});else console.warn(`Warning: Could not find 'extracted_metadata' object in JSON block from ${t}. Schema will be empty.`);return y}catch(e){if("ENOENT"===e.code)return console.warn("Analyzer instructions file not found: "+t),null;throw console.error(`Error retrieving or processing schema for analyzer ${r}: `+e.message),e}}async function deleteAnalyzer(t,r){if("string"!=typeof t||""===t.trim())return{success:!1,message:"analyzeMessagesBasePath is required."};if("string"!=typeof r||""===r.trim())return{success:!1,message:"analyzerId is required."};var e=r.split("::");if(3!==e.length)return{success:!1,message:`Invalid analyzerId format. Expected 'analyzer_name::content_type::instructions_type', but got '${r}'.`};var[e,a,n]=e,t=path.join(t,e),s=path.join(t,a),i=path.join(s,n),o=path.join(i,"1.md");try{if((await readConfig(t))?.protected)return{success:!1,message:`Analyzer '${e}' is protected and cannot be deleted.`};if((await readConfig(s))?.protected)return{success:!1,message:`Content type '${a}' for analyzer '${e}' is protected and cannot be deleted.`};if((await readConfig(i))?.protected)return{success:!1,message:`Instructions type '${n}' for content type '${a}' is protected and cannot be deleted.`};try{await fs.unlink(o)}catch(e){if("ENOENT"===e.code)return{success:!1,message:`Analyzer instructions file not found: ${o}. It may have already been deleted.`};throw e}var c=[];if(await isDirectoryEmpty(i))try{await fs.rmdir(i),c.push(i)}catch(e){console.warn(`Warning: Could not remove empty instructions directory ${i}: `+e.message)}if(await isDirectoryEmpty(s))try{await fs.rmdir(s),c.push(s)}catch(e){console.warn(`Warning: Could not remove empty content directory ${s}: `+e.message)}if(await isDirectoryEmpty(t))try{await fs.rmdir(t),c.push(t)}catch(e){console.warn(`Warning: Could not remove empty analyzer directory ${t}: `+e.message)}return{success:!0,message:`Analyzer '${r}' deleted successfully. Cleaned up directories: ${c.join(", ")||"None"}.`}}catch(e){return console.error(`Error deleting analyzer '${r}': `+e.message),{success:!1,message:"Failed to delete analyzer: "+e.message}}}module.exports={getAnalyzers:getAnalyzers,getAnalyzerSchema:getAnalyzerSchema,deleteAnalyzer:deleteAnalyzer};
