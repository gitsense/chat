<!--
Component: Extending GitSense Chat: Custom Handlers & Decorators
Block-UUID: 6d820e12-74d3-4790-a99e-c5974886eb28
Parent-UUID: N/A
Version: 1.0.0
Description: Technical guide to GitSense Chat's handler architecture for creating custom tools and interactive elements.
Language: HTML
Created-at: 2025-07-30T20:22:29.046Z
Authors: Gemini 2.5 Flash Thinking (v1.0.0)
-->


> GitSense Chat Help: Documents / Technical / Custom Handlers & Decorators

### Custom Handlers & Decorators

GitSense Chat is designed to be highly extensible, allowing you to tailor its functionality to your specific data needs and workflows. This section provides a technical guide to our handler architecture, empowering developers and administrators to create custom tools and interactive elements directly within chat messages.

#### Quick Demonstration

Take a moment to scroll to the very bottom of this message. You'll notice a "View the rest of the message" link. This link appears because a special `---split---` marker is embedded within this document. This marker was processed by a **custom handler**, demonstrating how you can easily create your own handlers to build interactive elements in GitSense Chat. Click the pencil icon at the bottom of this message to reveal the full content and see this in action!
  

#### Handler Architecture Overview

Messages in GitSense Chat are more than just plain text. They can contain hidden instructions, specifically `gitsense-tool` code blocks, that trigger specialized "handlers" in the frontend.  This architecture allows the application to transform static LLM output into dynamic, interactive UI components.

*   **`gitsense-tool` Blocks:** These are JSON objects embedded within Markdown messages. They define the `tool` to be invoked (e.g., `"context-loader"`, `"search"`) and provide a `config` object with parameters for that tool.
*   **`MainHandler` Dispatching:** When the `ConversationView` processes an assistant message, it scans for these `gitsense-tool` blocks. A central `MainHandler` then dispatches the rendering and logic to the appropriate individual handler module based on the `tool` specified.
*   **Role of Individual Handler Modules:** Each handler module (e.g., `contextMessageHandler.js`, `patchHandler.js`, `chatIdsHandler.js`) is responsible for:
    *   Parsing the `config` from the `gitsense-tool` block.
    *   Dynamically rendering the corresponding interactive UI elements within the chat message.
    *   Implementing the logic for user interactions with that UI (e.g., button clicks, form submissions).
    *   Interacting with backend APIs as needed.

This modular design ensures that new interactive features can be added without modifying core application code, making GitSense Chat highly adaptable.

#### Creating Custom Handlers

You can develop and register your own custom handlers to extend GitSense Chat's capabilities. This allows you to integrate external data sources, automate workflows, or create unique interactive experiences tailored to your organization's needs.

**Step-by-step guide on developing and registering new GitSense Chat Tool handlers:**

1.  **Identify the Need:** Determine what kind of interactive element or data integration you want to add. What information will the LLM provide that you want to make actionable?
2.  **Define LLM Output Pattern:** Design a specific `gitsense-tool` block structure that your LLM will generate in its responses to trigger your custom handler. This includes the `tool` name and any necessary `config` parameters.
3.  **Develop the Handler Module:**
    *   Create a new JavaScript module (e.g., `myCustomHandler.js`).
    *   This module will contain functions to:
        *   **`render(renderTo, config, chat, widget)`:** This function will be called by the `MainHandler` to render your custom UI into the `renderTo` DOM element. It will receive the `config` object from the `gitsense-tool` block, along with the current `chat` object and `widget` instance for API calls.
        *   Implement event listeners for user interactions (e.g., button clicks, input changes).
        *   Make necessary API calls to your backend or external services.
4.  **Register the Handler:** Integrate your new handler module into the `MainHandler`'s dispatching logic. This typically involves adding an entry to a central registry that maps your `tool` name to your handler module.
5.  **Test:** Thoroughly test your handler to ensure it correctly parses LLM output, renders the UI, and performs its intended actions.

**Step-by-step guide on developing and registering non GitSense Chat Tool handlers:**

A refactor of the main rendering module for handlers is required to ensure users can easily add custom handlers. Once the refactor has finished, we will share these instructions.

#### Decorator Patterns & Use Cases

"Decorators" in GitSense Chat refer to the transformation of static LLM output into dynamic, actionable elements. This is achieved through custom handlers. Here are common patterns and real-world use cases:

*   **Clickable Links/References:**
    *   **Pattern:** LLM outputs an identifier (e.g., Jira ticket number, file path, internal document ID).
    *   **Handler:** Recognizes the identifier, converts it into a clickable link that opens the corresponding resource in a new tab or triggers an in-app action (e.g., opening a modal with details).
    *   **Use Case:** Jira integration (Jira ticket numbers become clickable links to the actual tickets), linking to internal documentation, linking to specific lines of code in a web-based IDE.
*   **Data Visualizations/Summaries:**
    *   **Pattern:** LLM outputs structured data (e.g., a JSON array of metrics, a list of security vulnerabilities).
    *   **Handler:** Parses the data and renders it as an interactive chart, a sortable table, or a collapsible summary.
    *   **Use Case:** Displaying code complexity metrics, visualizing test coverage, summarizing log analysis results.
*   **Automated Actions/Workflow Triggers:**
    *   **Pattern:** LLM suggests an action (e.g., "This code needs a new branch," "Create a new task for this bug").
    *   **Handler:** Presents a button or form that, when clicked, triggers an API call to an external system (e.g., GitHub API to create a branch, Jira API to create a ticket).
    *   **Use Case:** One-click branch creation, automated task assignment, triggering CI/CD pipelines.
*   **Contextual Information Expansion:**
    *   **Pattern:** LLM references a concept or entity.
    *   **Handler:** Provides a "Learn More" button or hover-over tooltip that fetches and displays additional information about that concept/entity without leaving the chat.
    *   **Use Case:** Expanding on technical terms, showing definitions for domain-specific jargon.

#### Analyzer Integration with Handlers

Custom Analyzers and custom handlers work hand-in-hand to create powerful data analysis and interaction workflows.

*   **Analyzers Generate Metadata:** As discussed, Analyzers are LLM-powered tools that extract structured data (metadata) from unstructured content (code, documents). This metadata conforms to a defined schema.
*   **Handlers Leverage Metadata:** New custom handlers can be designed to specifically leverage this extracted metadata.
    *   **Filtering:** A handler could render a UI that allows users to filter the *current conversation's messages* based on metadata extracted from those messages (e.g., "show me all assistant messages that contain a security vulnerability").
    *   **Display:** A handler could display a summary of metadata for a given message or file, or even generate a visualization based on aggregated metadata from multiple messages.
    *   **Actionable Insights:** Metadata like `needs_review: true` could trigger a handler to display a "Flag for Review" button.

By combining custom Analyzers (for data extraction) with custom Handlers (for interactive display and action), you can build highly sophisticated, AI-driven data analysis and workflow automation directly within GitSense Chat.

---split---

You won't see this by default.
